<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hero Game - Survival Labirinto</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; }
    </style>
</head>
<body>
    <script>
        const config = {
            type: Phaser.CANVAS, 
            width: 800,
            height: 600,
            backgroundColor: '#2d3436',
            physics: {
                default: 'arcade',
                arcade: { debug: false }
            },
            scene: { preload, create, update }
        };

        const game = new Phaser.Game(config);
        let player, cursors, fomeText, paredes, npcVermelho, npcPreto;
        let fome = 100;
        let gameOver = false;

        const mapa = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,0,1,0,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
            [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        function preload() {
            this.load.image('boneco', 'hero_all_black.png');

            // Texturas criadas via Canvas
            let wallCanvas = this.textures.createCanvas('wallTex', 40, 40);
            wallCanvas.context.fillStyle = '#636e72';
            wallCanvas.context.fillRect(0, 0, 38, 38);
            wallCanvas.refresh();

            let foodCanvas = this.textures.createCanvas('foodTex', 16, 16);
            foodCanvas.context.fillStyle = '#2ecc71';
            foodCanvas.context.beginPath();
            foodCanvas.context.arc(8, 8, 8, 0, Math.PI * 2);
            foodCanvas.context.fill();
            foodCanvas.refresh();

            let npcRedCanvas = this.textures.createCanvas('npcRedTex', 30, 30);
            npcRedCanvas.context.fillStyle = '#ff0000';
            npcRedCanvas.context.fillRect(0, 0, 30, 30);
            npcRedCanvas.refresh();

            let npcBlackCanvas = this.textures.createCanvas('npcBlackTex', 30, 30);
            npcBlackCanvas.context.fillStyle = '#000000';
            npcBlackCanvas.context.fillRect(0, 0, 30, 30);
            npcBlackCanvas.refresh();
        }

        function create() {
            paredes = this.physics.add.staticGroup();
            for (let row = 0; row < mapa.length; row++) {
                for (let col = 0; col < mapa[row].length; col++) {
                    if (mapa[row][col] === 1) {
                        paredes.create(col * 40 + 20, row * 40 + 20, 'wallTex');
                    }
                }
            }

            player = this.physics.add.sprite(60, 60, 'boneco');
            player.setDisplaySize(45, 45);
            player.body.setSize(180, 220); // Ajuste para o player passar melhor nos vãos
            player.setCollideWorldBounds(true);

            // Criar NPCs
            npcVermelho = this.physics.add.sprite(400, 300, 'npcRedTex');
            npcPreto = this.physics.add.sprite(700, 400, 'npcBlackTex');

            // Configurar cada um usando a mesma inteligência reaproveitada
            configurarNPC(this, npcVermelho, 120, false);
            configurarNPC(this, npcPreto, 160, true);

            // Colisão do player com o labirinto
            this.physics.add.collider(player, paredes);

            // Comida
            const foods = this.physics.add.group();
            const gerarComida = () => {
                let r, c;
                do {
                    r = Phaser.Math.Between(1, mapa.length - 2);
                    c = Phaser.Math.Between(1, mapa[0].length - 2);
                } while (mapa[r][c] !== 0);
                foods.create(c * 40 + 20, r * 40 + 20, 'foodTex');
            }
            for(let i = 0; i < 6; i++) gerarComida();

            cursors = this.input.keyboard.createCursorKeys();
            fomeText = this.add.text(20, 20, 'FOME: 100%', { 
                fontSize: '24px', fill: '#fff', backgroundColor: '#00000088', padding: { x: 10, y: 5 }
            });

            this.physics.add.overlap(player, foods, (p, f) => {
                f.destroy();
                fome = Math.min(fome + 20, 100);
                gerarComida();
            });

            this.time.addEvent({
                delay: 1000,
                callback: () => { if(fome > 0 && !gameOver) fome -= 1.5; },
                loop: true
            });
        }

        function mudarDirecao(entidade, velocidade) {
            if (gameOver || fome <= 0) {
                entidade.setVelocity(0);
                return;
            }
            const escolhas = [
                {x: velocidade, y: 0}, {x: -velocidade, y: 0}, 
                {x: 0, y: velocidade}, {x: 0, y: -velocidade}
            ];
            const dir = Phaser.Utils.Array.GetRandom(escolhas);
            entidade.setVelocity(dir.x, dir.y);
        }

        function configurarNPC(scene, entidade, velocidade, ehInimigo) {
            entidade.setCollideWorldBounds(true);
            entidade.setImmovable(true); // Impede o player de empurrar o NPC
            entidade.body.setSize(28, 28); // Hitbox levemente menor que o corredor (40px) para não travar

            // Inteligência para não bugar na parede (Reaproveitada)
            scene.physics.add.collider(entidade, paredes, () => {
                if (entidade.body.touching.left) entidade.x += 5;
                if (entidade.body.touching.right) entidade.x -= 5;
                if (entidade.body.touching.up) entidade.y += 5;
                if (entidade.body.touching.down) entidade.y -= 5;
                mudarDirecao(entidade, velocidade);
            });

            if (ehInimigo) {
                // NPC PRETO: Se tocar, Game Over
                scene.physics.add.overlap(player, entidade, () => finalizarJogo(scene, 'VOCÊ MORREU!'));
            } else {
                // NPC VERMELHO: Apenas bloqueia a passagem
                scene.physics.add.collider(player, entidade);
            }

            mudarDirecao(entidade, velocidade);
            
            scene.time.addEvent({
                delay: 2500,
                callback: () => mudarDirecao(entidade, velocidade),
                loop: true
            });
        }

        function finalizarJogo(scene, mensagem) {
            if (gameOver) return;
            gameOver = true;
            fome = 0;
            fomeText.setText(mensagem);
            player.setTint(0xff0000);
            scene.physics.pause();
        }

        function update() {
            if (gameOver) return;

            const speed = 200;
            player.setVelocity(0);

            if (fome > 0) {
                if (cursors.left.isDown) player.setVelocityX(-speed);
                else if (cursors.right.isDown) player.setVelocityX(speed);
                if (cursors.up.isDown) player.setVelocityY(-speed);
                else if (cursors.down.isDown) player.setVelocityY(speed);
                
                if (player.body.velocity.x !== 0 && player.body.velocity.y !== 0) {
                    player.body.velocity.normalize().scale(speed);
                }
            }

            fomeText.setText('FOME: ' + Math.floor(fome) + '%');
            
            if (fome <= 0) {
                finalizarJogo(this, 'FIM DE JOGO!');
            }
        }
    </script>
</body>
</html>